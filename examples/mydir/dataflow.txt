Notes from https://www.cl.cam.ac.uk/teaching/1718/OptComp/slides/lecture03.pdf

Motivation

Programs may contain:
 * code which gets executed but which has no useful effect on the program's overall result
 * occurrences of variables being used before they are defined; and (isn't this undefined behaviour?)
 * many variables which need to be allocated registers and/or memory locations for compilation

The concept of variable liveness is useful in dealing with all of these situations.

Liveness is a data-flow property of variables: "Is the value of this variable needed?"

Liveness

At each instruction, each variable in the program is either live or dead.

We therefore usually consider liveness from an instruction's perspective: each instruction
has an associated set of live variables.

A variable x is "semantically live" at node n if there is some execution sequence starting
at n whose (externally observable) behaviour can be affected by changing the value of x.

"""
int x = y * z; // x LIVE
...
return x;
"""

"""
int x = y * z; // x DEAD
...
x = a + b;
...
return x;
"""

A variable is syntactically live at a node if there is a path to the exit of the
CFG along which its value may be used before it is redefined.

"""
int t = x * y; // t DEAD
if ((x+1)*(x+1) == y)
    t = 1;
if (x*x + 2*x + 1 != y)
    t = 2;
return t;
"""

Semantically: one of the conditions will be true, so on every execution path t
is redefined before it is returned. The value assigned by the first instruction
is never used.


